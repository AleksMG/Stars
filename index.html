<!DOCTYPE html>
<html>
<head>
    <title>AI Vigen√®re Cracker PRO</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@1.3.2"></script>
    <style>
        body { font-family: 'Courier New', monospace; background: #0f0f23; color: #00ff00; }
        .container { max-width: 900px; margin: 0 auto; padding: 20px; }
        textarea { 
            width: 100%; height: 150px; background: #000020; color: #00ff00; 
            border: 1px solid #005500; padding: 10px; font-family: inherit;
            margin-bottom: 10px;
        }
        button {
            background: #003300; color: #00ff00; border: 1px solid #005500; 
            padding: 10px 15px; margin: 5px; cursor: pointer; font-family: inherit;
        }
        #output { 
            background: #000020; padding: 15px; margin-top: 20px; 
            border: 1px solid #005500; white-space: pre-wrap;
            min-height: 100px;
        }
        .progress-container {
            margin: 15px 0; border: 1px solid #005500; height: 10px;
        }
        .progress-bar { 
            height: 100%; background: #00ff00; width: 0%; 
            transition: width 0.3s;
        }
        .status-line {
            display: flex; justify-content: space-between;
            margin: 10px 0; color: #ffff00;
        }
        .ai-feedback {
            color: #00ffff; margin: 10px 0; padding: 10px;
            border-left: 3px solid #00ffff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê AI Vigen√®re Cracker PRO</h1>
        <div class="status-line">
            <span id="model-status">[ ] Loading AI models...</span>
            <span id="workers-status">[ ] Workers: 0 active</span>
        </div>
        
        <textarea id="ciphertext" placeholder="Enter Vigen√®re-encrypted text here..."></textarea>
        
        <div>
            <button onclick="startAttack()">üöÄ START AI ATTACK</button>
            <button onclick="stopAttack()" style="background:#330000;">üõë STOP</button>
            <button onclick="showSettings()">‚öôÔ∏è SETTINGS</button>
        </div>
        
        <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        
        <div id="ai-feedback" class="ai-feedback">[AI] System ready</div>
        <div id="output"></div>
    </div>

    <script>
        // ======================
        // AI CORE SYSTEM
        // ======================
        const AICracker = {
            models: {
                keyPredictor: null,
                languageModel: null,
                encoder: null
            },
            state: {
                isRunning: false,
                bestResult: null,
                iterations: 0
            },
            
            async init() {
                logOutput("[SYSTEM] Initializing AI engine...");
                updateAIFeedback("Loading neural networks...");
                
                try {
                    // –ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏ –¥–ª—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –∫–ª—é—á–µ–π
                    this.models.keyPredictor = await tf.loadGraphModel(
                        'https://storage.googleapis.com/ai-crypto-models/key-predictor/model.json'
                    );
                    
                    // –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —ç–Ω–∫–æ–¥–µ—Ä —Ç–µ–∫—Å—Ç–∞
                    this.models.encoder = await use.load();
                    
                    // –Ø–∑—ã–∫–æ–≤–∞—è –º–æ–¥–µ–ª—å –¥–ª—è –æ—Ü–µ–Ω–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                    this.models.languageModel = await tf.loadLayersModel(
                        'https://storage.googleapis.com/ai-crypto-models/language-model/model.json'
                    );
                    
                    document.getElementById('model-status').textContent = "[‚úì] AI models loaded";
                    logOutput("[SYSTEM] AI initialization complete");
                    updateAIFeedback("Neural networks ready");
                    return true;
                } catch (error) {
                    document.getElementById('model-status').textContent = "[√ó] AI load failed";
                    logOutput(`[ERROR] AI init failed: ${error.message}`);
                    updateAIFeedback("Failed to load AI components");
                    return false;
                }
            },
            
            async predictKeys(ciphertext, context = {}) {
                if (!this.models.keyPredictor) return [];
                
                const input = this.prepareInput(ciphertext, context);
                const output = await this.models.keyPredictor.executeAsync(input);
                const keys = await this.processOutput(output);
                return keys;
            },
            
            prepareInput(text, context) {
                // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–∞ –≤ —á–∏—Å–ª–æ–≤—ã–µ –≤–µ–∫—Ç–æ—Ä—ã
                const encoded = this.textToVector(text);
                const constraints = tf.tensor1d([
                    context.minKeyLength || 1,
                    context.maxKeyLength || 20
                ]);
                
                return {
                    'ciphertext_input': tf.tensor2d([encoded]),
                    'constraints_input': constraints
                };
            },
            
            async scoreText(text) {
                // –û—Ü–µ–Ω–∫–∞ "–∞–Ω–≥–ª–∏–π—Å–∫–æ—Å—Ç–∏" —Ç–µ–∫—Å—Ç–∞
                const embedding = await this.models.encoder.embed([text]);
                const prediction = await this.models.languageModel.predict(embedding).data();
                return prediction[0];
            }
        };

        // ======================
        // WORKER MANAGEMENT
        // ======================
        const WorkerManager = {
            workers: [],
            activeWorkers: 0,
            taskQueue: [],
            
            init(count = 4) {
                for (let i = 0; i < count; i++) {
                    const worker = new Worker('worker.js');
                    worker.id = i;
                    worker.busy = false;
                    worker.onmessage = this.handleWorkerMessage;
                    this.workers.push(worker);
                }
                updateWorkerStatus();
            },
            
            async processTask(task) {
                const availableWorker = this.workers.find(w => !w.busy);
                if (!availableWorker) {
                    this.taskQueue.push(task);
                    return;
                }
                
                availableWorker.busy = true;
                this.activeWorkers++;
                updateWorkerStatus();
                
                availableWorker.postMessage({
                    type: 'DECRYPT',
                    ciphertext: task.ciphertext,
                    key: task.key
                });
            },
            
            handleWorkerMessage(event) {
                const { type, result, progress } = event.data;
                
                switch (type) {
                    case 'RESULT':
                        AICracker.evaluateResult(result);
                        break;
                    case 'PROGRESS':
                        updateProgress(progress);
                        break;
                }
                
                if (type === 'RESULT' || type === 'ERROR') {
                    this.workers.find(w => w.id === event.target.id).busy = false;
                    this.activeWorkers--;
                    updateWorkerStatus();
                    
                    if (this.taskQueue.length > 0) {
                        this.processTask(this.taskQueue.shift());
                    }
                }
            }
        };

        // ======================
        // MAIN APPLICATION
        // ======================
        async function startAttack() {
            if (AICracker.state.isRunning) return;
            
            const ciphertext = document.getElementById('ciphertext').value.trim();
            if (!ciphertext) {
                alert("Please enter ciphertext to decrypt!");
                return;
            }
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã
            if (!AICracker.models.keyPredictor) {
                const success = await AICracker.init();
                if (!success) return;
            }
            
            AICracker.state.isRunning = true;
            logOutput(`[ATTACK] Starting AI attack on ciphertext (${ciphertext.length} chars)`);
            updateAIFeedback("Analyzing ciphertext structure...");
            
            // –ü–µ—Ä–≤–∏—á–Ω—ã–π –∞–Ω–∞–ª–∏–∑
            const analysisStart = performance.now();
            const initialKeys = await AICracker.predictKeys(ciphertext);
            updateAIFeedback(`Generated ${initialKeys.length} initial key candidates`);
            
            // –ó–∞–ø—É—Å–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏
            initialKeys.forEach(key => {
                WorkerManager.processTask({
                    ciphertext,
                    key
                });
            });
            
            logOutput(`[SYSTEM] Attack started with ${initialKeys.length} initial keys`);
        }
        
        function stopAttack() {
            AICracker.state.isRunning = false;
            WorkerManager.workers.forEach(w => w.terminate());
            WorkerManager.init();
            logOutput("[SYSTEM] Attack stopped by user");
            updateAIFeedback("Attack interrupted");
        }

        // ======================
        // UI FUNCTIONS
        // ======================
        function logOutput(message) {
            const output = document.getElementById('output');
            output.textContent += message + '\n';
            output.scrollTop = output.scrollHeight;
        }
        
        function updateProgress(percent) {
            document.getElementById('progress-bar').style.width = `${percent}%`;
        }
        
        function updateWorkerStatus() {
            const elem = document.getElementById('workers-status');
            elem.textContent = `[${WorkerManager.activeWorkers}/${WorkerManager.workers.length}] Workers active`;
        }
        
        function updateAIFeedback(message) {
            document.getElementById('ai-feedback').textContent = `[AI] ${message}`;
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.onload = () => {
            WorkerManager.init();
            logOutput("[SYSTEM] Worker system initialized");
            logOutput("[SYSTEM] Ready for ciphertext input");
        };
    </script>
</body>
</html>
