<!DOCTYPE html>
<html>
<head>
    <title>Vigen√®re Cracker PRO</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@1.3.3"></script>
    <style>
        body { font-family: 'Courier New', monospace; background: #0f0f0f; color: #00ffaa; }
        .container { max-width: 1000px; margin: 0 auto; padding: 20px; }
        textarea { 
            width: 100%; height: 150px; background: #111; color: #00ffaa; 
            border: 1px solid #005500; padding: 10px; font-family: inherit;
        }
        button {
            background: #005500; color: #00ffaa; border: none; padding: 10px 15px;
            margin: 5px; cursor: pointer; font-family: inherit;
        }
        #output { 
            background: #111; padding: 15px; margin-top: 20px; 
            border: 1px solid #005500; white-space: pre-wrap;
        }
        .progress { height: 5px; background: #003300; margin: 10px 0; }
        .progress-bar { height: 100%; background: #00ffaa; width: 0%; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîì Vigen√®re Cracker PRO</h1>
        
        <textarea id="ciphertext" placeholder="Paste Vigen√®re-encrypted text here..."></textarea>
        <button onclick="crackVigenere()">CRACK VIGEN√àRE</button>
        
        <div class="progress" id="progress">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        
        <div id="key-info"></div>
        <div id="output">[SYSTEM READY]</div>
    </div>

    <script>
        // ======================
        // CORE VIGEN√àRE CRACKER
        // ======================
        const VigenereCracker = {
            model: null,
            
            async init() {
                this.model = await use.load();
                logOutput("[+] AI model loaded");
            },
            
            // –ü–æ–ª–Ω—ã–π —Ü–∏–∫–ª –≤–∑–ª–æ–º–∞
            async crack(ciphertext) {
                // 1. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–ª–∏–Ω—É –∫–ª—é—á–∞ (–ö–∞—Å–∏—Å–∫–∏)
                const keyLength = this.findKeyLength(ciphertext);
                logOutput(`[+] Estimated key length: ${keyLength}`);
                
                // 2. –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ –≥—Ä—É–ø–ø—ã –ø–æ –∫–ª—é—á—É
                const groups = this.splitIntoGroups(ciphertext, keyLength);
                
                // 3. –î–ª—è –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø—ã –Ω–∞—Ö–æ–¥–∏–º —Å–¥–≤–∏–≥
                let key = '';
                for (let i = 0; i < keyLength; i++) {
                    updateProgress(i / keyLength * 100);
                    const shift = this.findShift(groups[i]);
                    key += String.fromCharCode(shift + 97);
                    logOutput(`[+] Key char ${i+1}: ${key.charAt(i)} (shift ${shift})`);
                }
                
                // 4. –î–µ—à–∏—Ñ—Ä—É–µ–º
                const decrypted = this.decrypt(ciphertext, key);
                
                // 5. –í–µ—Ä–∏—Ñ–∏—Ü–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                const score = await this.evaluateText(decrypted);
                
                return {
                    key: key,
                    text: decrypted,
                    confidence: score
                };
            },
            
            // –ú–µ—Ç–æ–¥ –ö–∞—Å–∏—Å–∫–∏ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–ª–∏–Ω—ã –∫–ª—é—á–∞
            findKeyLength(text) {
                const seqs = {};
                // –ò—â–µ–º –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è 3-—Å–∏–º–≤–æ–ª—å–Ω—ã–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
                for (let i = 0; i < text.length - 3; i++) {
                    const seq = text.substr(i, 3);
                    if (seqs[seq]) seqs[seq].push(i);
                    else seqs[seq] = [i];
                }
                
                // –í—ã—á–∏—Å–ª—è–µ–º –ù–û–î —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π –º–µ–∂–¥—É –ø–æ–≤—Ç–æ—Ä–∞–º–∏
                const distances = [];
                for (const seq in seqs) {
                    if (seqs[seq].length > 1) {
                        for (let i = 1; i < seqs[seq].length; i++) {
                            distances.push(seqs[seq][i] - seqs[seq][0]);
                        }
                    }
                }
                
                // –ù–∞–∏–±–æ–ª–µ–µ –≤–µ—Ä–æ—è—Ç–Ω–∞—è –¥–ª–∏–Ω–∞ –∫–ª—é—á–∞ - –ù–û–î –≤—Å–µ—Ö —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π
                return this.gcdArray(distances) || 3;
            },
            
            // –ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –ù–û–î –º–∞—Å—Å–∏–≤–∞ —á–∏—Å–µ–ª
            gcdArray(arr) {
                if (arr.length === 0) return 0;
                let result = arr[0];
                for (let i = 1; i < arr.length; i++) {
                    result = this.gcd(result, arr[i]);
                    if (result === 1) return 1;
                }
                return result;
            },
            
            gcd(a, b) {
                return b ? this.gcd(b, a % b) : a;
            },
            
            // –†–∞–∑–±–∏–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –≥—Ä—É–ø–ø—ã
            splitIntoGroups(text, keyLength) {
                const groups = Array(keyLength).fill().map(() => []);
                for (let i = 0; i < text.length; i++) {
                    if (/[a-z]/i.test(text[i])) {
                        groups[i % keyLength].push(text[i].toLowerCase());
                    }
                }
                return groups;
            },
            
            // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å–¥–≤–∏–≥–∞ –¥–ª—è –≥—Ä—É–ø–ø—ã
            findShift(group) {
                const freq = this.analyzeFrequency(group.join(''));
                const englishFreq = [8.2, 1.5, 2.8, 4.3, 12.7, 2.2, 2.0, 6.1, 7.0, 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0, 6.3, 9.1, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1];
                
                let bestShift = 0;
                let bestScore = 0;
                
                for (let shift = 0; shift < 26; shift++) {
                    let score = 0;
                    for (const char in freq) {
                        const index = (char.charCodeAt(0) - 97 - shift + 26) % 26;
                        score += freq[char] * englishFreq[index];
                    }
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestShift = shift;
                    }
                }
                
                return bestShift;
            },
            
            // –ê–Ω–∞–ª–∏–∑ —á–∞—Å—Ç–æ—Ç —Å–∏–º–≤–æ–ª–æ–≤
            analyzeFrequency(text) {
                const freq = {};
                for (const char of text.toLowerCase()) {
                    if (/[a-z]/.test(char)) {
                        freq[char] = (freq[char] || 0) + 1;
                    }
                }
                return freq;
            },
            
            // –î–µ—à–∏—Ñ—Ä–æ–≤–∫–∞ —Å –∏–∑–≤–µ—Å—Ç–Ω—ã–º –∫–ª—é—á–æ–º
            decrypt(text, key) {
                let result = '';
                key = key.toLowerCase();
                let keyIndex = 0;
                
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    if (/[a-z]/i.test(char)) {
                        const shift = key.charCodeAt(keyIndex % key.length) - 97;
                        result += this.caesarDecrypt(char, shift);
                        keyIndex++;
                    } else {
                        result += char;
                    }
                }
                
                return result;
            },
            
            caesarDecrypt(char, shift) {
                const code = char.charCodeAt(0);
                const shiftAmount = code >= 97 ? 97 : 65;
                return String.fromCharCode(((code - shiftAmount - shift + 26) % 26) + shiftAmount);
            },
            
            // –û—Ü–µ–Ω–∫–∞ —Ç–µ–∫—Å—Ç–∞ –ò–ò
            async evaluateText(text) {
                const embedding = await this.model.embed(text);
                const scores = await tf.tensor([1, 0]).dot(embedding).array();
                return scores[0];
            }
        };
        
        // ======================
        // UI FUNCTIONS
        // ======================
        function logOutput(msg) {
            document.getElementById('output').textContent += '\n' + msg;
        }
        
        function updateProgress(percent) {
            document.getElementById('progress-bar').style.width = percent + '%';
        }
        
        async function crackVigenere() {
            const text = document.getElementById('ciphertext').value;
            if (!text) return alert("Enter ciphertext!");
            
            document.getElementById('output').textContent = "[CRACKING...]";
            document.getElementById('progress').style.display = 'block';
            
            try {
                const result = await VigenereCracker.crack(text);
                
                document.getElementById('key-info').innerHTML = `
                    <h3>Found Key: <span style="color:#ffff00">${result.key}</span></h3>
                    <p>Confidence: ${(result.confidence * 100).toFixed(1)}%</p>
                `;
                
                logOutput("\n[+] DECRYPTED TEXT:");
                logOutput(result.text);
            } catch (error) {
                logOutput("\n[ERROR] " + error.message);
            }
        }
        
        // Initialize
        window.onload = async () => {
            await VigenereCracker.init();
        };
    </script>
</body>
</html>
